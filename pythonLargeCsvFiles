import pandas as pd
import oracledb

# Configurations
csv_file_path = "large_file.csv"  # Path to your CSV
table_name = "your_table_name"
username = "your_username"
password = "your_password"
dsn = "your_host:your_port/your_service_name"  # e.g., localhost:1521/orclpdb1
batch_size = 1000  # Adjust based on your memory/DB load

# Initialize thick mode
oracledb.init_oracle_client(lib_dir="/path/to/instantclient")

try:
    # Connect to Oracle using thick mode
    with oracledb.connect(user=username, password=password, dsn=dsn) as conn:
        with conn.cursor() as cursor:

            # Read the CSV in chunks
            for chunk in pd.read_csv(csv_file_path, chunksize=batch_size):
                # Dynamically generate insert SQL
                cols = ', '.join(chunk.columns)
                placeholders = ', '.join([f':{i+1}' for i in range(len(chunk.columns))])
                insert_sql = f"INSERT INTO {table_name} ({cols}) VALUES ({placeholders})"

                # Convert DataFrame chunk to list of tuples
                data = [tuple(row) for row in chunk.itertuples(index=False, name=None)]

                # Execute batch insert
                cursor.executemany(insert_sql, data)
                conn.commit()
                print(f"‚úÖ Inserted {len(data)} rows")

    print("üéâ All data inserted successfully.")

except Exception as e:
    print("‚ùå Error occurred:", e)






import pandas as pd

def read_csv_file_in_chunks(file_path, chunk_size):
    """Reads a CSV file in chunks and prints each chunk."""
    for chunk in pd.read_csv(file_path, chunksize=chunk_size):
        print("üì¶ New Chunk:")
        print(chunk)
        print("=" * 40)

# ---------------------- Testing ----------------------

# Configuration
csv_file_path = "large_file.csv"   # Replace with your actual CSV path
batch_size = 5                     # Small chunk size for demonstration

# Call the test function
read_csv_file_in_chunks(csv_file_path, batch_size)



    with open(file_path, 'rb') as f:  # open in binary mode
        # decode using ISO-8859-1, replace bad characters with ÔøΩ
        text_stream = io.TextIOWrapper(f, encoding='ISO-8859-1', errors='replace')
