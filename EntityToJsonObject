import org.json.JSONObject;
import java.lang.reflect.Field;

public class GenericTransformer {

    public static <T> JSONObject transformToJSONObject(T object) {
        JSONObject jsonObject = new JSONObject();

        // Use reflection to get the fields of the object
        Field[] fields = object.getClass().getDeclaredFields();

        for (Field field : fields) {
            try {
                // Ensure we can access the field's value
                field.setAccessible(true);

                // Get the field name and value
                String fieldName = field.getName();
                Object fieldValue = field.get(object);

                // Add the field to the JSONObject
                jsonObject.put(fieldName, fieldValue);
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Error accessing field: " + field.getName(), e);
            }
        }

        return jsonObject;
    }
}



public class UserEntity {
    private String id;
    private String name;

    // Constructor, getters, and setters
    public UserEntity(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

// Example usage
UserEntity user = new UserEntity("1", "John Doe");
JSONObject jsonObject = GenericTransformer.transformToJSONObject(user);

// Expected output: {"id": "1", "name": "John Doe"}
System.out.println(jsonObject.toString());




import org.json.JSONObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class GenericTransformerTest {

    @Test
    public void testTransformToJSONObject() {
        // Create a UserEntity instance to transform
        UserEntity user = new UserEntity("1", "John Doe");

        // Use the generic function to transform to JSONObject
        JSONObject jsonObject = GenericTransformer.transformToJSONObject(user);

        // Validate the contents of the JSONObject
        assertNotNull(jsonObject);
        assertEquals("1", jsonObject.getString("id")); // Validate 'id'
        assertEquals("John Doe", jsonObject.getString("name")); // Validate 'name'
    }
}


import org.json.JSONObject;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.*;

public class TransformerTest {

    static class SampleClass {
        public String publicField = "publicValue";
        private String privateField = "privateValue";
        protected int protectedField = 42;
    }

    static class NoFieldClass {}

    @Test
    void testTransformToJSONObject() {
        SampleClass sample = new SampleClass();
        JSONObject jsonObject = Transformer.transformToJSONObject(sample);

        assertNotNull(jsonObject);
        assertEquals("publicValue", jsonObject.get("publicField"));
        assertEquals("privateValue", jsonObject.get("privateField"));
        assertEquals(42, jsonObject.get("protectedField"));
    }

    @Test
    void testTransformWithNoFields() {
        NoFieldClass noFieldClass = new NoFieldClass();
        JSONObject jsonObject = Transformer.transformToJSONObject(noFieldClass);

        assertNotNull(jsonObject);
        assertTrue(jsonObject.isEmpty(), "Expected empty JSON object for class with no fields");
    }

    @Test
    void testIllegalAccessException() {
        class RestrictedClass {
            private final String sensitiveField = "sensitive";
        }

        RestrictedClass restricted = new RestrictedClass();

        // Making the field inaccessible to force an IllegalAccessException
        Field[] fields = RestrictedClass.class.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(false);  // Attempting to make the field inaccessible
        }

        Exception exception = assertThrows(RuntimeException.class, () -> {
            Transformer.transformToJSONObject(restricted);
        });

        String expectedMessage = "Error accessing field";
        assertTrue(exception.getMessage().contains(expectedMessage));
    }
}
